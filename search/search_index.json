{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the ChaosIQ Documentation ChaosIQ is the place where you can explore the reliability of your system using ChaosIQ's Reliability Workflow. Where you can describe what you care about and how to measure it, surface insights and respond to these insights to improve your system\u2019s reliability.","title":"Welcome"},{"location":"#welcome-to-the-chaosiq-documentation","text":"ChaosIQ is the place where you can explore the reliability of your system using ChaosIQ's Reliability Workflow. Where you can describe what you care about and how to measure it, surface insights and respond to these insights to improve your system\u2019s reliability.","title":"Welcome to the ChaosIQ Documentation"},{"location":"deployment-options/deployment-options/","text":"You can choose from three options for your deployment of ChaosIQ, depending on your subscription plan: ChaosIQ SaaS ChaosIQ Single-Tenant ChaosIQ Self-Hosted ChaosIQ SaaS In the early days of the free and open source Chaos Toolkit we knew that chaos experiments themselves had to executed and, more importantly, controlled \"in-house\". That was one of the motivating factors in the Chaos Toolkit's design: a simple CLI that you could use locally as easily as possible to explore how to do chaos engineering right with an emphasis on experiments. The Chaos Toolkit is still the open core of ChaosIQ and we remain as dedicated as ever to working closely with the whole community to make the toolkit as powerful as possible. At the same time, ChaosIQ is designed with a different, extended goal in mind. The Chaos Toolkit is specifically designed to help individuals and organizations write and execute powerful and customizable chaos engineering experiments. Whereas ChaosIQ is designed to help organisations scale out chaos engineering and system verification across all their teams. For this reason ChaosIQ provides a cross-organizational experience that include capabilities such as Safeguards , centralised dashboards and the authoring and execution of system verifications. All of this is provided in the first instance as a Software as a Service (SaaS), hosted by ChaosIQ on our own systems. The actual chaos engineering experiments, and system verifications, are still executed locally by the Chaos Toolkit, which is extended to add some of these capabilities including the ability to talk back to ChaosIQ: SaaS is the default deployment option for ChaosIQ. We host the SaaS, you run the ChaosIQ-extended Chaos Toolkit wherever you want. For those that don't want outside entities, such as ChaosIQ, to be instigating conditions in their systems, this model still fits as we don't, by default, instigate any experiments or verifications that you don't trigger yourself through the chaos run or chaos verify commands. One advantage of this approach is that you get the simplest and most friendly billing plan (more clarity on our pricing is coming in a future article) that is perfect (and, we're told, fair) for individuals as well as small and large organizations. One requirement though is that some data is pushed back to ChaosIQ so that it can apply features like Safeguards, Dashboards and Reliability Insights. For many, many customers this is a workable constraint but for those that need something different, we support two further deployment options: Single-Tenant and Self-Hosted. The Single-Tenant SaaS Option Some organizations don't want any of their data to even reside, regardless of how temporarily, on any systems that might contain other people's data. They might also need to make sure their ChaosIQ system is in a specific geography. However, they also don't need to run ChaosIQ themselves. For these customers, we provide the \"Single-Tenant\" deployment option: The Single-Tenant deployment option gives our customers all the features of ChaosIQ on their own, dedicated SaaS instances, often in their own preferred geography and/or on a preferred cloud provider, and still managed and supported by ChaosIQ. We keep single-tenant deployments constantly up-to-date with our multi-tenant SaaS and so there is no difference in the overall experience. The final category of users are those that really want to run ChaosIQ within their own organizational boundaries, however they choose to define those. In this specific case they opt for our \"Self Hosted\" deployment option. The Self-Hosted Option Self Hosted is often referred to as \"On Premise\" or an \"Enterprise Option\", although it really means that the customer has to meet the requiremenjt of running anything involved in system verification and chaos engineering, in any capacity, within and on their own systems: For these customers we provide auto-updates to their hosted ChaosIQ systems that mean they keep as up-to-date as they choose with the ChaosIQ-hosted SaaS while running our packaged software systems within their own world. What about customisation options? All of the three deployment options, from SaaS, Single-Tennant SaaS through to Self-Hosted, offers powerful features for customisation. Whether it be integrating experiments and verifications with your own systems, or building unique safeguards, the Chaos Toolkit was built with customisation in mind, and ChaosIQ leverage and contribute to that as well. By their nature, Self-Hosted deployments sometimes require more bespoke customisations with your systems and so part of the plan for those customers is to be able to opt for custom development from our ChaosIQ Special Ops team. Picking from the options Picking from one of the three options is as simple as: Do you absolutely need to run ChaosIQ for yourself? -> Talk to us about \"ChaosIQ Self-Hosted\" Do you need to have your own, dedicated ChaosIQ, possibly run in a specific geography or with a specific cloud provider, but you're happy that it is still managed and maintained by ChaosIQ? -> Talk to us about \"ChaosIQ Single-Tenant\" Do you want to use the most cost-effective and flexible option? -> Sign-up to the ChaosIQ SaaS","title":"Deployment Options"},{"location":"deployment-options/deployment-options/#chaosiq-saas","text":"In the early days of the free and open source Chaos Toolkit we knew that chaos experiments themselves had to executed and, more importantly, controlled \"in-house\". That was one of the motivating factors in the Chaos Toolkit's design: a simple CLI that you could use locally as easily as possible to explore how to do chaos engineering right with an emphasis on experiments. The Chaos Toolkit is still the open core of ChaosIQ and we remain as dedicated as ever to working closely with the whole community to make the toolkit as powerful as possible. At the same time, ChaosIQ is designed with a different, extended goal in mind. The Chaos Toolkit is specifically designed to help individuals and organizations write and execute powerful and customizable chaos engineering experiments. Whereas ChaosIQ is designed to help organisations scale out chaos engineering and system verification across all their teams. For this reason ChaosIQ provides a cross-organizational experience that include capabilities such as Safeguards , centralised dashboards and the authoring and execution of system verifications. All of this is provided in the first instance as a Software as a Service (SaaS), hosted by ChaosIQ on our own systems. The actual chaos engineering experiments, and system verifications, are still executed locally by the Chaos Toolkit, which is extended to add some of these capabilities including the ability to talk back to ChaosIQ: SaaS is the default deployment option for ChaosIQ. We host the SaaS, you run the ChaosIQ-extended Chaos Toolkit wherever you want. For those that don't want outside entities, such as ChaosIQ, to be instigating conditions in their systems, this model still fits as we don't, by default, instigate any experiments or verifications that you don't trigger yourself through the chaos run or chaos verify commands. One advantage of this approach is that you get the simplest and most friendly billing plan (more clarity on our pricing is coming in a future article) that is perfect (and, we're told, fair) for individuals as well as small and large organizations. One requirement though is that some data is pushed back to ChaosIQ so that it can apply features like Safeguards, Dashboards and Reliability Insights. For many, many customers this is a workable constraint but for those that need something different, we support two further deployment options: Single-Tenant and Self-Hosted.","title":"ChaosIQ SaaS"},{"location":"deployment-options/deployment-options/#the-single-tenant-saas-option","text":"Some organizations don't want any of their data to even reside, regardless of how temporarily, on any systems that might contain other people's data. They might also need to make sure their ChaosIQ system is in a specific geography. However, they also don't need to run ChaosIQ themselves. For these customers, we provide the \"Single-Tenant\" deployment option: The Single-Tenant deployment option gives our customers all the features of ChaosIQ on their own, dedicated SaaS instances, often in their own preferred geography and/or on a preferred cloud provider, and still managed and supported by ChaosIQ. We keep single-tenant deployments constantly up-to-date with our multi-tenant SaaS and so there is no difference in the overall experience. The final category of users are those that really want to run ChaosIQ within their own organizational boundaries, however they choose to define those. In this specific case they opt for our \"Self Hosted\" deployment option.","title":"The Single-Tenant SaaS Option"},{"location":"deployment-options/deployment-options/#the-self-hosted-option","text":"Self Hosted is often referred to as \"On Premise\" or an \"Enterprise Option\", although it really means that the customer has to meet the requiremenjt of running anything involved in system verification and chaos engineering, in any capacity, within and on their own systems: For these customers we provide auto-updates to their hosted ChaosIQ systems that mean they keep as up-to-date as they choose with the ChaosIQ-hosted SaaS while running our packaged software systems within their own world.","title":"The Self-Hosted Option"},{"location":"deployment-options/deployment-options/#what-about-customisation-options","text":"All of the three deployment options, from SaaS, Single-Tennant SaaS through to Self-Hosted, offers powerful features for customisation. Whether it be integrating experiments and verifications with your own systems, or building unique safeguards, the Chaos Toolkit was built with customisation in mind, and ChaosIQ leverage and contribute to that as well. By their nature, Self-Hosted deployments sometimes require more bespoke customisations with your systems and so part of the plan for those customers is to be able to opt for custom development from our ChaosIQ Special Ops team.","title":"What about customisation options?"},{"location":"deployment-options/deployment-options/#picking-from-the-options","text":"Picking from one of the three options is as simple as: Do you absolutely need to run ChaosIQ for yourself? -> Talk to us about \"ChaosIQ Self-Hosted\" Do you need to have your own, dedicated ChaosIQ, possibly run in a specific geography or with a specific cloud provider, but you're happy that it is still managed and maintained by ChaosIQ? -> Talk to us about \"ChaosIQ Single-Tenant\" Do you want to use the most cost-effective and flexible option? -> Sign-up to the ChaosIQ SaaS","title":"Picking from the options"},{"location":"faq/plugin/","text":"How do I check I have the latest version of the ChaosIQ plugin? To connect the Chaos Toolkit to ChaosIQ you need to install and run the chaosiq-cloud plugin . The plugin is added to the python environment where you run the Chaos Toolkit, so navigate to you terminal window where you have the Chaos Toolkit setup, and enter: $ pip search 'chaosiq' chaosiq-cloud ( 0 .10.0 ) - ChaosIQ plugin for the Chaos Toolkit CLI INSTALLED: 0 .9.0 LATEST: 0 .10.0 The output shows in this case version 0.9.0 of the chaosiq-cloud is installed and the latest version is 0.10.0. Normally you would expect to be using the latest version if you want to install the latest version enter: pip install --upgrade chaosiq-cloud The command will output a lot of dependency information for the chaosiq-cloud package, which is omitted for brevity, but it will finish with the following text: Installing collected packages: chaosiq-cloud Attempting uninstall: chaosiq-cloud Found existing installation: chaosiq-cloud 0 .9.0 Uninstalling chaosiq-cloud-0.9.0: Successfully uninstalled chaosiq-cloud-0.9.0 Successfully installed chaosiq-cloud-0.10.0 This shows the package has now been installed with the latest version.","title":"How do I check I have the latest version of the ChaosIQ plugin"},{"location":"faq/plugin/#how-do-i-check-i-have-the-latest-version-of-the-chaosiq-plugin","text":"To connect the Chaos Toolkit to ChaosIQ you need to install and run the chaosiq-cloud plugin . The plugin is added to the python environment where you run the Chaos Toolkit, so navigate to you terminal window where you have the Chaos Toolkit setup, and enter: $ pip search 'chaosiq' chaosiq-cloud ( 0 .10.0 ) - ChaosIQ plugin for the Chaos Toolkit CLI INSTALLED: 0 .9.0 LATEST: 0 .10.0 The output shows in this case version 0.9.0 of the chaosiq-cloud is installed and the latest version is 0.10.0. Normally you would expect to be using the latest version if you want to install the latest version enter: pip install --upgrade chaosiq-cloud The command will output a lot of dependency information for the chaosiq-cloud package, which is omitted for brevity, but it will finish with the following text: Installing collected packages: chaosiq-cloud Attempting uninstall: chaosiq-cloud Found existing installation: chaosiq-cloud 0 .9.0 Uninstalling chaosiq-cloud-0.9.0: Successfully uninstalled chaosiq-cloud-0.9.0 Successfully installed chaosiq-cloud-0.10.0 This shows the package has now been installed with the latest version.","title":"How do I check I have the latest version of the ChaosIQ plugin?"},{"location":"gettingstarted/first-objective/","text":"Ensure you have a team selected using the drop-down at the to left of the ChaosIQ console. Then navigate to the Objectives page and click the Create a New Objective button. On the Objective form specify an Objective you care about for your system. First you need to add a meaningful name for your Objective. An objective's name should mean something of value to the business or the your customers. You can also add an optional description to elaborate on your Objective. You can optionally add a tag to your Objective. Tags are used to filter for your objective when you are managing many Objectives. You now specify the most important part of your objective which is a target percentage availability over a specified period, an example could be 99.5% available, over a period of 7 days. The target availability is less than 100% so this leaves a margin for error, this can be considered the Error Budget . The next step is to identify how you would measure your Objective. This is something in your that you can measure that is an indicator that the system is meeting its objectives. In ChaosIQ, select the drop-down menu for the type of measurement. Note Currently there are a limited number of options for the type of measurement but these should expand over time as ChaosIQ evolves. Select a measure from the drop-down such as HTTP status code . The fields displayed on the Create Objective form will dynamically update depending on the drop-down field you have selected. For HTTP status code you will be able to enter a URL you are going to probe and a tolerance for that probe. The tolerance can be either HTTP Status Code Check where you will specify an explicit expected status code as a response. Alternatively, you could select a range of HTTP Status codes, where you specify a lower and upper bound for the expected response code. Having identified how you are going to measure your objective select the Create Objective and Verify It button to complete your objective and it will take you to the Create a Verification form.","title":"Create your first Objective"},{"location":"gettingstarted/first-verification/","text":"First you need to indicate what objective this verification is being built for. An objective maye be pre-selected, or you will need to select the objective from the drop-down list. Then you will enter a frequency in seconds and over what duration your verification will be run. The values chosen on these fields impact your usage footprint in ChaosIQ so a high usage warning may be displayed. Next you will select and specify the conditions you want to apply as part of your verification. The first option is to apply No Condition, this means you are going to measure you verification but you are not going to apply an adverse effect as part of your Verification. This is a good case for a control Verification as it establishes how the Verification performs in normal conditions. In this case leave the condition as No Condition and select the Create Verification and View Execution Steps button to on to the Run your Verification page. Finally you are prompted to give your verification a name that reflects what this Verification is going to do. Based on the objective you are verifying, and the conditions that you selected, a name for your new verification will have been created and suggested for you. If you prefer you can override this suggestion with a name of your own. An example could be is Ensure My Service remains available when a Web Service POD restarts.","title":"Create your first Verification"},{"location":"gettingstarted/introduction/","text":"This document will show you the steps to run your first Verification with the Chaos Toolkit and publish the results to ChaosIQ. The workflow in ChaosIQ is organized around Objectives and Verifications . Objectives identify the parts of your system that you care about and are highly related to what keeps your users happy. Verifications explore the impact on your objectives under various conditions, such as failures. We will go through the steps required to get your first Verification running and published into ChaosIQ: Prerequisites . Login to ChaosIQ . Sign-in Chaos Toolkit to ChaosIQ . Create your first Objective . Create your first Verification . Run your first Verification .","title":"Introduction"},{"location":"gettingstarted/login-chaosiq/","text":"When you open https://console.chaosiq.io in your browser you will be presented with the ChaosIQ login page: When you select your preferred authentication provider you will be prompted for the required authentication details. Once you have authenticated you will be presented with the ChaosIQ Welcome page: You can enter your preferred email address at this point, this can be different from the email address provided by the authentication provider. You are also asked to accept ChaosIQ terms of Service and give ChaosIQ permission to store your data. You will then be asked to choose a plan, ChaosIQ are currently only offering the Early Access Plan (more plans will follow): Normally at this point users subscribe and create an Organization and teams to start using the ChaosIQ tools. If you select Subscribe Now you will be prompted for an Organization name: Note You can optionally to skip this stage for now, if you do so see Skipping subscription . Enter an Organization name, the Organization name has to be unique, it can't be one that has been used before within ChaosIQ. You will then be asked to create a team. Teams are where your Objectives are defined and where Chaos Experiments are run. It can represent a real-life team, or a specific project or system Once you have created the team name you will be taken to your teams start page where you can go on to create your first objective . That\u2019s it! You have authenticated and logged in to ChaosIQ, you have created your Organization and a Team you are all set to start using the ChaosIQ tools. Skipping subscription If you selected to Skip this at the subscribe stage you will be taken to the ChaosIQ start page: You have a number of choices from here, including links to articles, links to the ChaosIQ documentation and a useful video on Verification workflow. If you select Create an Organization, you will then be taken back to the Subscribe page.","title":"Login to ChaosIQ"},{"location":"gettingstarted/login-chaosiq/#skipping-subscription","text":"If you selected to Skip this at the subscribe stage you will be taken to the ChaosIQ start page: You have a number of choices from here, including links to articles, links to the ChaosIQ documentation and a useful video on Verification workflow. If you select Create an Organization, you will then be taken back to the Subscribe page.","title":"Skipping subscription"},{"location":"gettingstarted/prerequisites/","text":"ChaosIQ Prerequisites Before getting started with running your first Verification with the Chaos Toolkit and publish the results to ChaosIQ, some prerequisite steps are required. We will go through the prerequisite steps so you are ready to get your first Verification running and published into ChaosIQ: Install the Chaos Toolkit . Add the ChaosIQ Plugin . Access to ChaosIQ . If you\u2019ve already got a working installation of the Chaos Toolkit CLI then you can skip directly to Add the ChaosIQ Plugin Creating a new Chaos Toolkit CLI Installation using pip The Chaos Toolkit CLI is implemented in Python 3 and so needs a working Python installation at version 3.5+. When you execute the python3 command on your machine you see something like the following then you are all set: $ python3 --version Python 3.7.6 If you see a version lower than 3.5 then you\u2019ll first need to install a later version of Python. This is well documented on the Chaos Toolkit install page Create a Python Virtual Environment Dependencies can be installed for your Python installation through pip and it\u2019s often a good idea to create a Python Virtual Environment to contain your Chaos Toolkit CLI installation libraries. To create a Python virtual environment called chaostk execute the following: python3 -m venv ~/.venvs/chaostk Now you can activate your virtual environment by executing: $ source ~/.venvs/chaostk/bin/activate (chaostk) $ Tip You may want to use virtualenvwrapper to make this process much nicer. Install the Chaos Toolkit CLI using pip You install the Chaos Toolkit CLI as the Python chaostoolkit module into your virtual environment by using pip: (chaostk) $ pip install chaostoolkit You can verify the Chaos Toolkit CLI was installed by running: (chaostk) $ chaos --version chaos, version 1.4.1 Add the ChaosIQ Plugin to your Chaos Toolkit In order for the Chaos Toolkit to communicate with ChaosIQ you need to add the chaosiq-cloud plugin to your Chaos Toolkit installation. The chaosiq-cloud plugin is a Python package and can be found in the Python Package Index (PyPI) chaosiq-cloud . The ChaosIQ features can be added to your Chaos Toolkit CLI installation by executing: ( chaostk ) $ pip install chaosiq-cloud Access to ChaosIQ The next thing you will need is access to ChaosIQ. You will need access to https://console.chaosiq.io . This link should take you to the login page: Authentication Currently ChaosIQ supports two authentication providers Github and Google, so you will need either a Google account or a Github account, that you can use. This is really only required for the authentication step, after you login you can change the email address you wish to use and create your organization as required. That\u2019s it! You\u2019ve got a working installation of the Chaos Toolkit CLI and the chaosiq-cloud plugin installed. You have access to ChaosIQ and hopefully have a Github or Google account that you can authenticate with. The next step is Login to ChaosIQ .","title":"Prerequisites"},{"location":"gettingstarted/prerequisites/#chaosiq-prerequisites","text":"Before getting started with running your first Verification with the Chaos Toolkit and publish the results to ChaosIQ, some prerequisite steps are required. We will go through the prerequisite steps so you are ready to get your first Verification running and published into ChaosIQ: Install the Chaos Toolkit . Add the ChaosIQ Plugin . Access to ChaosIQ . If you\u2019ve already got a working installation of the Chaos Toolkit CLI then you can skip directly to Add the ChaosIQ Plugin","title":"ChaosIQ Prerequisites"},{"location":"gettingstarted/prerequisites/#creating-a-new-chaos-toolkit-cli-installation-using-pip","text":"The Chaos Toolkit CLI is implemented in Python 3 and so needs a working Python installation at version 3.5+. When you execute the python3 command on your machine you see something like the following then you are all set: $ python3 --version Python 3.7.6 If you see a version lower than 3.5 then you\u2019ll first need to install a later version of Python. This is well documented on the Chaos Toolkit install page","title":"Creating a new Chaos Toolkit CLI Installation using pip"},{"location":"gettingstarted/prerequisites/#create-a-python-virtual-environment","text":"Dependencies can be installed for your Python installation through pip and it\u2019s often a good idea to create a Python Virtual Environment to contain your Chaos Toolkit CLI installation libraries. To create a Python virtual environment called chaostk execute the following: python3 -m venv ~/.venvs/chaostk Now you can activate your virtual environment by executing: $ source ~/.venvs/chaostk/bin/activate (chaostk) $ Tip You may want to use virtualenvwrapper to make this process much nicer.","title":"Create a Python Virtual Environment"},{"location":"gettingstarted/prerequisites/#install-the-chaos-toolkit-cli-using-pip","text":"You install the Chaos Toolkit CLI as the Python chaostoolkit module into your virtual environment by using pip: (chaostk) $ pip install chaostoolkit You can verify the Chaos Toolkit CLI was installed by running: (chaostk) $ chaos --version chaos, version 1.4.1","title":"Install the Chaos Toolkit CLI using pip"},{"location":"gettingstarted/prerequisites/#add-the-chaosiq-plugin-to-your-chaos-toolkit","text":"In order for the Chaos Toolkit to communicate with ChaosIQ you need to add the chaosiq-cloud plugin to your Chaos Toolkit installation. The chaosiq-cloud plugin is a Python package and can be found in the Python Package Index (PyPI) chaosiq-cloud . The ChaosIQ features can be added to your Chaos Toolkit CLI installation by executing: ( chaostk ) $ pip install chaosiq-cloud","title":"Add the ChaosIQ Plugin to your Chaos Toolkit"},{"location":"gettingstarted/prerequisites/#access-to-chaosiq","text":"The next thing you will need is access to ChaosIQ. You will need access to https://console.chaosiq.io . This link should take you to the login page:","title":"Access to ChaosIQ"},{"location":"gettingstarted/prerequisites/#authentication","text":"Currently ChaosIQ supports two authentication providers Github and Google, so you will need either a Google account or a Github account, that you can use. This is really only required for the authentication step, after you login you can change the email address you wish to use and create your organization as required. That\u2019s it! You\u2019ve got a working installation of the Chaos Toolkit CLI and the chaosiq-cloud plugin installed. You have access to ChaosIQ and hopefully have a Github or Google account that you can authenticate with. The next step is Login to ChaosIQ .","title":"Authentication"},{"location":"gettingstarted/run-first-verification/","text":"ChaosIQ will display the Run Verification page showing the Chaos Verify command with a URL selecting you Verification. To run the Verification select the Copy button, which will capture the command in your clipboard. Open the terminal window where you set-up your Chaos Toolkit and paste in the Chaos Verify command and select enter to run it. The command should run the Verification and publish the results to ChaosIQ. If you go to the Verifications page and select your Verification, you should be able to see the current state of the Verification. The Insights page will give you a view of your Verifications that have completed. This will give you an indication of the timeline of the Verification and a view of the events that occurred when the Verification was running. It is from the insights page that you should be able to learn the impact of your Verification and determine what actions are required. To view, the results select the Insights menu option. That's your first Verification created, run and published to ChaosIQ. The results are now made available on the Insights page. From the Insights page you can select the Details button and you can see the details view of the insight. The details view includes information about the Objective, the Measurement used and the Verification. It shows the Verification Run Timeline that includes a timeline chart of samples. Next steps are to add Conditions to your Verification to see what, if any, impact this might have on your Objective.","title":"Run your first Verification"},{"location":"gettingstarted/signin/","text":"So that your Chaos Toolkit installation can communicate with ChaosIQ, you need to set up your credentials using the chaos signin command. First generate a token from the ChaosIQ Tokens tab . Enter a token name and click the Generate Token button: Click the Copy To Clipboard button and the token will be copied to your clipboard, ready to be added to your Chaos Toolkit CLI by signing into ChaosIQ. Use the chaos signin command to connect to ChaosIQ and add your token. When the chaos signin command prompts for the token, paste the token from your clipboard: (chaostk) $ chaos signin ChaosIQ Cloud url [https://console.chaosiq.io]: ChaosIQ Cloud token: Experiments and executions will be published to organization 'MyName' ChaosIQ Cloud details saved at ~/.chaostoolkit/settings.yaml Your Chaos toolkit will now publish executions to ChaosIQ.","title":"Sign-in Chaos Toolkit to ChaosIQ"},{"location":"organizations-and-teams/create-organization/","text":"An organization is created when a person signs in to ChaosIQ without having been previously invited to join an organization.","title":"Creating an Organization"},{"location":"organizations-and-teams/creating-a-team/","text":"You can create an unlimited number of teams in your organization. Teams can be used to gather real-life teams or members of different teams working on common projects. They are a flexible model that should be able to fit the way you and your teammates want to work. Opening the Teams dropdown in the top-left corner of the window will list your available teams as well as allow you to create a new one. Click the Add a team button. On the Create a new Team page, you are asked to choose a name for your organization. When you are happy with your team name, click the Create Team button. A message will appear, telling you your organization was successfully created. This new organization is now listed in the top-left Teams menu. Clicking on its name will take you to the new teams' Objectives. Alternatively, you can use the Teams link in the top menu to view a list of the organizations you belong too and create new ones. Adding members to a team In a team view, click on the People link in the sidebar menu to display the list of all this team's members. Click on the Add members button to display a list of all people that can be added to this team (they are the people in your organization that are not yet members of this team).","title":"Creating a Team"},{"location":"organizations-and-teams/creating-a-team/#adding-members-to-a-team","text":"In a team view, click on the People link in the sidebar menu to display the list of all this team's members. Click on the Add members button to display a list of all people that can be added to this team (they are the people in your organization that are not yet members of this team).","title":"Adding members to a team"},{"location":"organizations-and-teams/invite-to-an-organization/","text":"From the organization view, click on the People link in the sidebar to display a list of the members of your organization. Click on the Invite people button to invite people to join the organization. Enter a comma-separated Email list and invites will be sent when you select the Send Invites button. Joining an organization When you have been invited to join an organization, signing in to ChaosIQ will automatically make you a member of this organization.","title":"Inviting people to your Organization"},{"location":"organizations-and-teams/invite-to-an-organization/#joining-an-organization","text":"When you have been invited to join an organization, signing in to ChaosIQ will automatically make you a member of this organization.","title":"Joining an organization"},{"location":"organizations-and-teams/organizations-and-teams-intro/","text":"Introduction to Organizations and Teams A system's resilience is rarely the responsibility of a single person. Even if you are someone whose job title explicitly mentions resilience, resilience is a cross-socio-technical system goal. Everyone shojuld be aware of the system's objectives and how, andf when, those objectives are being verified using ChaosIQ, so that's why we support the familiar setup of Organisations and Teams to help everyone organise their efforts. Organizations allow a high level view of everything that is happening. Most of the time, your organization in ChaosIQ will represent your real-life organisation or company. In your organization view you can get a list of all objectives and verifications ever run and pusdhed to ChaosIQ. Teams are where the work happens. They are shared workspaces where people can collaborate on objectives, verifications, insights and even see the activity on action items.","title":"Introduction"},{"location":"organizations-and-teams/organizations-and-teams-intro/#introduction-to-organizations-and-teams","text":"A system's resilience is rarely the responsibility of a single person. Even if you are someone whose job title explicitly mentions resilience, resilience is a cross-socio-technical system goal. Everyone shojuld be aware of the system's objectives and how, andf when, those objectives are being verified using ChaosIQ, so that's why we support the familiar setup of Organisations and Teams to help everyone organise their efforts. Organizations allow a high level view of everything that is happening. Most of the time, your organization in ChaosIQ will represent your real-life organisation or company. In your organization view you can get a list of all objectives and verifications ever run and pusdhed to ChaosIQ. Teams are where the work happens. They are shared workspaces where people can collaborate on objectives, verifications, insights and even see the activity on action items.","title":"Introduction to Organizations and Teams"},{"location":"organizations-and-teams/publishing-to-a-team/","text":"For Chaos Toolkit to send Verifications and Executions data to a team, you must have the ChaosIQ Cloud extension installed. $ pip install -U chaosiq-cloud Then, sign in to ChaosIQ $ chaos signin You will be asked the URL of ChaosIQ. It defaults to https://console.chaosiq.io, for SaaS users. If you use an an alternative deployment, change it to your URL and your choice will be remembered next time you sign in. ChaosIQ then asks for a token to identify you. To generate a new token, click on the Tokens link from the top menu. Click on Generate a Token to create a new token. Once you have chosen a name for your token, click on the Generate Token button. A message is displayed with your token. Copy it, then switch back to your terminal and paste it. Chaos Toolkit will then retrieve the list of organizations you belong to and asks you to choose which one you will publish to. If you only belong to one organization, ChaosIQ will skip this step. You are then asked to select which team you want to publish your experiments to. Select the one you want, and you are ready to run experiments. If you run an experiment with the chaos run command, it will now be published to ChaosIQ and available on the Executions page.","title":"Publishing Verifications to a Team"},{"location":"organizations-and-teams/switching-organizations/","text":"If you want to select a team from another organizations, use the chaos org command and you will be asked to select an organization and a team.","title":"Switching Organizations"},{"location":"organizations-and-teams/switching-teams/","text":"Run the chaos team command again to be able to choose a new default team to publish to.","title":"Switching Teams"},{"location":"reliability-workflow/reliability-workflow/","text":"The ChaosIQ Reliability Workflow ChaosIQ provides a Reliability Workflow. The Reliability Workflow\u2019s job is to help you proactively verify your system to gain insights into its reliability so that you can then prioritize and track work on improving that reliability alongside the regular work that you need to do on features. There are lots of good reasons to verify your system. You might be worried about surprise downtime and looking to try to anticipate and prepare better for incidents. You might also be curious as to how your system might respond to challenging conditions, and want to explore that before your users do. In a nutshell you want to verify your system because you care about your users\u2019 experience, and specifically about the reliability of that experience. With ChaosIQ, the goal of system verification is not only to show the impact that various conditions might have on your users happiness but to also turn those insights into prioritized, meaningful actions for improving a system's reliability. ChaosIQ brings this System Reliability Workflow to life with Objectives, Verifications, Insights and Action Items: Objectives and Measurements Objectives are literally things you care about. If you care about it, and can measure it, then it\u2019s an objective. You might care that your homepage is available 99.9% of the time. You might care that your database is able to respond to a particular query under an amount of time. Or you might care that your users can interact with your system, perform some system function, 99.999% of the time as it\u2019s super-critical! These are all Objectives, and they frame what\u2019s important to you about your system. A good set of Objectives represents a great high-level description of how your system aims to behave, from your perspective, in order to make your users happy. However, an Objective is not particularly useful unless it can be measured. Objectives can be measured in lots of different ways, often in combination, to give you some confidence that an Objective, at a given moment, is being met: The job of a measurement, or combination of measurements, is to be able provide a sample, an event, that is either \"successful\" or \"failing\" at a given moment in time. For example, you might measure that the response time for your homepage is within a tolerable time bracket at a given moment and, if it is within that tolerance, then it is a \"successful\" sample event. If the measurement shows that the homepage URL does not respond in the tolerated time, then the sample event would be designated \"failed\": The combination of Objectives and their corresponding measurements provides a shared understanding of how your system needs to behave in order to keep your users happy. This is the all-important framing necessary to then decide what you want to verify in order to see how your Objectives, and your users\u2019 happiness, is affected by your system\u2019s behavior under various conditions. TBD link to where you can define objectives in the Getting Started. Verifications Verifying an Objective helps you build trust and confidence in how your system will behave under a set of interesting conditions. Those conditions could be behavior such as security intrusions, infrastructure failures, platform failures, application failures, interesting user behavior or even administrative changes. In fact, anything that you can conceive of that could happen to your system could be an interesting scenario to explore if you think there\u2019s a likelihood that it may have an impact on one or more of your system\u2019s Objectives. In our book, \u201dLearning Chaos Engineering\u201d by O'Reilly Media , a couple of ways of exploring the conditions you might want to explore are covered. In addition, when you are designing a Verification you have the all-important framing of the overall Objective to help you. The Objective helps you decide and prioritize what verifications to perform that will give you the most effective insights, not least because you may want to perform the verification in production where there is likely more risk from the exploration. For example, you might decide that you want to verify how your system behaves when: A virtual machine fails A network starts to lose packets A configuration change is made A Kubernetes Pod, or collection of pods, fail A cluster is starved of resources, such as nodes A database begins to respond slowly The list will go on, and you will almost certainly have your own unique conditions that you\u2019re interested in. This is one of the reasons why ChaosIQ is built on top of the free and open source Chaos Toolkit , which makes ChaosIQ an easily customizable and extendable system verification and chaos engineering environment. You need that flexibility, because your conditions will often be unique to your systems. The first thing you describe in a Verification is the types of conditions you want to introduce to see how this affects your system\u2019s behaviour in respect of your overall Objective. A verification then needs a description of how it will be executed. While a verification is running it will be capturing your Objective\u2019s measurements throughout, continuously gathering sample events that indicate whether the measurement was successful or failed in reference to the overall Objective: A Verification needs two pieces of information to run itself: Duration and Frequency of Measurement. Duration is self-explanatory, it\u2019s the total duration that you want the verification to be executed for. For example, you might want to run a Verification as the backdrop to a 3-hour GameDay (More on how to do this in a forthcoming article) so, as you\u2019d expect, you\u2019d set the duration of the Verification in this case to 3 hours. Frequency of Measurement describes just how often you will want to gather a sample event from the system as described by a Measurement for your Objective. You might want to sample every second, or perhaps sampling a measurement every 10 minutes will give you the fidelity you\u2019re looking for. As you run your Verification, all of the data captured by your Measurements\u2019 sample events are collated for interpretation into Insights. Insights When your Verification has been executed the resulting, potentially large, set of data collated from all the sample event measurements is captured and made available to you. This timeline of event samples in its raw form can be useful but the most common first step is to try to assess what impact on your Objective was seen by those measurements during your verification\u2019s execution. This insight is called the \u201cObjective Impact\u201d. The \"Objective Impact\" insight is a calculation based on the duration of the verification and how many failed sample events were measured. The insight gives you an extrapolated indicator of what size of impact the conditions of your verification have on your Objective. This information is key to then decide whether the impact is so minor that your system survived just fine, or whether it\u2019s actually time to assemble your teams and look to the next stage of the workflow: Action Items. Action Items (coming soon) Insights give you the information you and your teams need to decide what to do to improve your system\u2019s reliability. The insights are framed by the objectives you care about and so you have everything you need to be able to understand and prioritize what should be done and when. What should be done and when are Action Items. Action Items are how you describe what system reliability improvements you are going to work on. You describe them in ChaosIQ while you analyze the insights from your Verifications. Then track their progress and eventually impacts on future Verification executions. ChaosIQ integrates with the systems you normally use to capture, prioritize and track your work, i.e. issue trackers. ChaosIQ mirrors Action Items as issues in your regular toolset so you can work on this reliability work and its progress is mirrored back into ChaosIQ. Action Items close the learning loop of the System Verification workflow. Each time you and your teams create new Verifications and explore more and more insights, you will describe and action more reliability improvements balancing your need to innovate at speed with the need to provide a system your users can rely on.","title":"The Reliability Workflow"},{"location":"reliability-workflow/reliability-workflow/#the-chaosiq-reliability-workflow","text":"ChaosIQ provides a Reliability Workflow. The Reliability Workflow\u2019s job is to help you proactively verify your system to gain insights into its reliability so that you can then prioritize and track work on improving that reliability alongside the regular work that you need to do on features. There are lots of good reasons to verify your system. You might be worried about surprise downtime and looking to try to anticipate and prepare better for incidents. You might also be curious as to how your system might respond to challenging conditions, and want to explore that before your users do. In a nutshell you want to verify your system because you care about your users\u2019 experience, and specifically about the reliability of that experience. With ChaosIQ, the goal of system verification is not only to show the impact that various conditions might have on your users happiness but to also turn those insights into prioritized, meaningful actions for improving a system's reliability. ChaosIQ brings this System Reliability Workflow to life with Objectives, Verifications, Insights and Action Items:","title":"The ChaosIQ Reliability Workflow"},{"location":"reliability-workflow/reliability-workflow/#objectives-and-measurements","text":"Objectives are literally things you care about. If you care about it, and can measure it, then it\u2019s an objective. You might care that your homepage is available 99.9% of the time. You might care that your database is able to respond to a particular query under an amount of time. Or you might care that your users can interact with your system, perform some system function, 99.999% of the time as it\u2019s super-critical! These are all Objectives, and they frame what\u2019s important to you about your system. A good set of Objectives represents a great high-level description of how your system aims to behave, from your perspective, in order to make your users happy. However, an Objective is not particularly useful unless it can be measured. Objectives can be measured in lots of different ways, often in combination, to give you some confidence that an Objective, at a given moment, is being met: The job of a measurement, or combination of measurements, is to be able provide a sample, an event, that is either \"successful\" or \"failing\" at a given moment in time. For example, you might measure that the response time for your homepage is within a tolerable time bracket at a given moment and, if it is within that tolerance, then it is a \"successful\" sample event. If the measurement shows that the homepage URL does not respond in the tolerated time, then the sample event would be designated \"failed\": The combination of Objectives and their corresponding measurements provides a shared understanding of how your system needs to behave in order to keep your users happy. This is the all-important framing necessary to then decide what you want to verify in order to see how your Objectives, and your users\u2019 happiness, is affected by your system\u2019s behavior under various conditions. TBD link to where you can define objectives in the Getting Started.","title":"Objectives and Measurements"},{"location":"reliability-workflow/reliability-workflow/#verifications","text":"Verifying an Objective helps you build trust and confidence in how your system will behave under a set of interesting conditions. Those conditions could be behavior such as security intrusions, infrastructure failures, platform failures, application failures, interesting user behavior or even administrative changes. In fact, anything that you can conceive of that could happen to your system could be an interesting scenario to explore if you think there\u2019s a likelihood that it may have an impact on one or more of your system\u2019s Objectives. In our book, \u201dLearning Chaos Engineering\u201d by O'Reilly Media , a couple of ways of exploring the conditions you might want to explore are covered. In addition, when you are designing a Verification you have the all-important framing of the overall Objective to help you. The Objective helps you decide and prioritize what verifications to perform that will give you the most effective insights, not least because you may want to perform the verification in production where there is likely more risk from the exploration. For example, you might decide that you want to verify how your system behaves when: A virtual machine fails A network starts to lose packets A configuration change is made A Kubernetes Pod, or collection of pods, fail A cluster is starved of resources, such as nodes A database begins to respond slowly The list will go on, and you will almost certainly have your own unique conditions that you\u2019re interested in. This is one of the reasons why ChaosIQ is built on top of the free and open source Chaos Toolkit , which makes ChaosIQ an easily customizable and extendable system verification and chaos engineering environment. You need that flexibility, because your conditions will often be unique to your systems. The first thing you describe in a Verification is the types of conditions you want to introduce to see how this affects your system\u2019s behaviour in respect of your overall Objective. A verification then needs a description of how it will be executed. While a verification is running it will be capturing your Objective\u2019s measurements throughout, continuously gathering sample events that indicate whether the measurement was successful or failed in reference to the overall Objective: A Verification needs two pieces of information to run itself: Duration and Frequency of Measurement. Duration is self-explanatory, it\u2019s the total duration that you want the verification to be executed for. For example, you might want to run a Verification as the backdrop to a 3-hour GameDay (More on how to do this in a forthcoming article) so, as you\u2019d expect, you\u2019d set the duration of the Verification in this case to 3 hours. Frequency of Measurement describes just how often you will want to gather a sample event from the system as described by a Measurement for your Objective. You might want to sample every second, or perhaps sampling a measurement every 10 minutes will give you the fidelity you\u2019re looking for. As you run your Verification, all of the data captured by your Measurements\u2019 sample events are collated for interpretation into Insights.","title":"Verifications"},{"location":"reliability-workflow/reliability-workflow/#insights","text":"When your Verification has been executed the resulting, potentially large, set of data collated from all the sample event measurements is captured and made available to you. This timeline of event samples in its raw form can be useful but the most common first step is to try to assess what impact on your Objective was seen by those measurements during your verification\u2019s execution. This insight is called the \u201cObjective Impact\u201d. The \"Objective Impact\" insight is a calculation based on the duration of the verification and how many failed sample events were measured. The insight gives you an extrapolated indicator of what size of impact the conditions of your verification have on your Objective. This information is key to then decide whether the impact is so minor that your system survived just fine, or whether it\u2019s actually time to assemble your teams and look to the next stage of the workflow: Action Items.","title":"Insights"},{"location":"reliability-workflow/reliability-workflow/#action-items-coming-soon","text":"Insights give you the information you and your teams need to decide what to do to improve your system\u2019s reliability. The insights are framed by the objectives you care about and so you have everything you need to be able to understand and prioritize what should be done and when. What should be done and when are Action Items. Action Items are how you describe what system reliability improvements you are going to work on. You describe them in ChaosIQ while you analyze the insights from your Verifications. Then track their progress and eventually impacts on future Verification executions. ChaosIQ integrates with the systems you normally use to capture, prioritize and track your work, i.e. issue trackers. ChaosIQ mirrors Action Items as issues in your regular toolset so you can work on this reliability work and its progress is mirrored back into ChaosIQ. Action Items close the learning loop of the System Verification workflow. Each time you and your teams create new Verifications and explore more and more insights, you will describe and action more reliability improvements balancing your need to innovate at speed with the need to provide a system your users can rely on.","title":"Action Items (coming soon)"},{"location":"run-and-verify/experiment-format/","text":"The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the Chaos Toolkit Samples project : { \"version\" : \"1.0.0\" , \"title\" : \"System is resilient to provider's failures\" , \"description\" : \"Can our consumer survive gracefully a provider's failure?\" , \"tags\" : [ \"service\" , \"kubernetes\" , \"spring\" ], \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"all-services-are-healthy\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"stop-provider-service\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"my-provider-service\" } }, \"pauses\" : { \"after\" : 10 } }, { \"ref\" : \"all-services-are-healthy\" }, { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://192.168.42.58:31018/invokeConsumedService\" } } ], \"rollbacks\" : [] } The key concepts of the Chaos Toolkit are Experiments , Steady State Hypothesis and the experiment's Method . The Method contains a combination of Probes and Actions . Experiments A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON. Steady State Hypothesis A Steady State Hypothesis describes \"what normal looks like\" for your system in order for the experiment to surface information about weaknesses when compared against the declared \"normal\" tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment's report. Method An experiment's activities are contained within its Method block. Probes A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation. Actions An action is a particular activity that needs to be enacted on the system under experimentation. Rollbacks An experiment may define a sequence of actions that revert what was undone during the experiment. For a more full explanation of the Experiment can be seen as part of the Chaos Toolkit documentation.","title":"Experiment Format"},{"location":"run-and-verify/experiment-format/#experiments","text":"A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON.","title":"Experiments"},{"location":"run-and-verify/experiment-format/#steady-state-hypothesis","text":"A Steady State Hypothesis describes \"what normal looks like\" for your system in order for the experiment to surface information about weaknesses when compared against the declared \"normal\" tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment's report.","title":"Steady State Hypothesis"},{"location":"run-and-verify/experiment-format/#method","text":"An experiment's activities are contained within its Method block.","title":"Method"},{"location":"run-and-verify/experiment-format/#probes","text":"A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation.","title":"Probes"},{"location":"run-and-verify/experiment-format/#actions","text":"An action is a particular activity that needs to be enacted on the system under experimentation.","title":"Actions"},{"location":"run-and-verify/experiment-format/#rollbacks","text":"An experiment may define a sequence of actions that revert what was undone during the experiment. For a more full explanation of the Experiment can be seen as part of the Chaos Toolkit documentation.","title":"Rollbacks"},{"location":"run-and-verify/run-and-verify-intro/","text":"The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, however this has now been extended to support verifications. Experiment Format . Verification Format . Chaos Run and Verify .","title":"Introduction"},{"location":"run-and-verify/run-and-verify/","text":"The Chaos Toolkit supports a number of commands and options, if you have Chaos Toolkit installed, execute the chaos command, you will see output like: Usage: chaos [ OPTIONS ] COMMAND [ ARGS ] ... Options: --version Show the version and exit. --verbose Display debug level traces. --no-version-check Do not search for an updated version of the chaostoolkit. --change-dir TEXT Change directory before running experiment. --no-log-file Disable logging to file entirely. --log-file TEXT File path where to write the command ' s log. [ default: chaostoolkit.log ] --log-format [ string | json ] Console logging format: string, json. --settings TEXT Path to the settings file. [ default: /Users/grant/.chaostoolkit/settings.yaml ] --help Show this message and exit. Commands: discover Discover capabilities and experiments. info Display information about the Chaos Toolkit environment. init Initialize a new experiment from discovered capabilities. run Run the experiment loaded from SOURCE, either a local file or a... validate Validate the experiment at PATH. This shows the core Chaos Toolkit support for the chaos run command. To add the ability to run Verifications and to publish the results to ChaosIQ you need to install the ChaosIQ Plugin . Once the plugin is installed run the chaos command again and you will see: Usage: chaos [ OPTIONS ] COMMAND [ ARGS ] ... Options: --version Show the version and exit. --verbose Display debug level traces. --no-version-check Do not search for an updated version of the chaostoolkit. --change-dir TEXT Change directory before running experiment. --no-log-file Disable logging to file entirely. --log-file TEXT File path where to write the command 's log. [default: chaostoolkit.log] --log-format [string|json] Console logging format: string, json. --settings TEXT Path to the settings file. [default: /Users/grant/.chaostoolkit/settings.yaml] --help Show this message and exit. Commands: disable Disable a ChaosIQ feature discover Discover capabilities and experiments. enable Enable a ChaosIQ feature info Display information about the Chaos Toolkit environment. init Initialize a new experiment from discovered capabilities. org Set ChaosIQ organisation publish Publish your experiment' s journal to ChaosIQ run Run the experiment loaded from SOURCE, either a local file or a... signin Sign-in with your ChaosIQ credentials team Set ChaosIQ team validate Validate the experiment at PATH. verify Run the verification loaded from SOURCE, either a local file or... The ChaosIQ plugin adds some additional commands to the core Chaos Toolkit CLI, this includes commands to signin to ChaosIQ and the command to verify . You now have availalbe chaos run to run an Experiment and chaos verify to run a Verification. The execution is different for both. Chaos Run the chaos run command will execute the experiment given as the SOURCE parameter, an experiment can be specified either a local file or a HTTP resource: ENDPOINT_URL = https://httpstat.us/200?sleep = 2000 ; \\ chaos run https://raw.githubusercontent.com/open-chaos/experiment-catalog/master/local/url-responds/url-responds.json will give output similar to: [ 2020 -03-18 10 :21:26 INFO ] Validating the experiment 's syntax [2020-03-18 10:21:26 INFO] Experiment looks valid [2020-03-18 10:21:26 INFO] Running experiment: Checks the hypothesis that a URL responds with a 200 status [2020-03-18 10:21:28 INFO] Execution available at http://console.chaosiq.dev/ChaosIQ/chaos-ebn/executions/6f38b6c5-cf44-4dec-a7b5-7ec6ee03352a [2020-03-18 10:21:29 INFO] Steady state hypothesis: Application is normal [2020-03-18 10:21:31 INFO] Probe: application-must-respond-normally [2020-03-18 10:21:35 INFO] Steady state hypothesis is met! [2020-03-18 10:21:38 INFO] Action: dummy step [2020-03-18 10:21:40 INFO] Steady state hypothesis: Application is normal [2020-03-18 10:21:43 INFO] Probe: application-must-respond-normally [2020-03-18 10:21:46 INFO] Steady state hypothesis is met! [2020-03-18 10:21:47 INFO] Let' s rollback... [ 2020 -03-18 10 :21:49 INFO ] No declared rollbacks, let ' s move on. [ 2020 -03-18 10 :21:50 INFO ] Experiment ended with status: completed If that same experiment is stored locally in a file e.g. url-responds.json , it can be executed as: ENDPOINT_URL = https://httpstat.us/200?sleep = 2000 ; \\ chaos run url-responds.json The output will be the same as shown above, the only difference is when the chaos run is provided with a URL it downloads the experiment from the HTTP resource first. The execution then performs the following steps: Validate the experiment and if it is syntactically valid it will run it. The steady state hypothesis is checked. Execute any methods in the experiment (the experiment can include an array of methods). The steady state hypothesis is then checked again. Finally if there are any rollbacks then these are executed. When connected to ChaosIQ the result of running an Experiment can be seen on the Executions pages: If you select the details button for your Experiment can view the detail of the execution: If you expand the Experiment Steady-State Hypothesis you can see the Steady-State used: Chaos Verify The chaos verify command is added to the Chaos Toolkit CLI by the ChaosIQ plugin. A chaos verify command will execute the verification provided the SOURCE parameter. A verification can be specified either a local file or a HTTP resource: chaos verify https://console.chaosiq.dev/assets/verifications/13e11c55-8fd9-4737-b43f-b62ea763cc6f.json If that same verification is downloaded and stored locally in a file e.g. verify-staging-dummy-action.json , it can be executed as: chaos verify verify-staging-dummy-action.json The output is similar for both commands: [ 2020 -03-18 12 :40:30 INFO ] Validating the experiment 's syntax [2020-03-18 12:40:30 INFO] Experiment looks valid [2020-03-18 12:40:30 INFO] Verification looks valid [2020-03-18 12:40:31 INFO] Execution available at http://console.chaosiq.dev/ChaosIQ/Staging/executions/68158971-8ed1-45fd-815c-a92233c402f9 [2020-03-18 12:40:33 INFO] Started run ' 8a99aadf-f9b9-4053-8a3f-ad4cb76ed55c ' of verification ' Staging Console should respond within 500 milliseconds with a dummy condition applied. ' [2020-03-18 12:40:34 INFO] Starting verification warm-up period of None seconds [2020-03-18 12:40:34 INFO] Finished verification warm-up [2020-03-18 12:40:34 INFO] Triggering verification conditions [2020-03-18 12:40:35 INFO] Starting verification measurement every 3 seconds [2020-03-18 12:40:35 INFO] Running verification measurement 1 [2020-03-18 12:40:35 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:35 INFO] Probe: http-response-time [2020-03-18 12:40:35 INFO] Steady state hypothesis is met! [2020-03-18 12:40:37 INFO] Action: dummy step [2020-03-18 12:40:39 INFO] Running verification measurement 2 [2020-03-18 12:40:39 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:39 INFO] Probe: http-response-time [2020-03-18 12:40:39 INFO] Steady state hypothesis is met! [2020-03-18 12:40:40 INFO] Finished triggering verification conditions [2020-03-18 12:40:40 INFO] Starting verification conditions for 10 seconds [2020-03-18 12:40:43 INFO] Running verification measurement 3 [2020-03-18 12:40:43 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:43 INFO] Probe: http-response-time [2020-03-18 12:40:44 INFO] Steady state hypothesis is met! [2020-03-18 12:40:48 INFO] Running verification measurement 4 [2020-03-18 12:40:48 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:48 INFO] Probe: http-response-time [2020-03-18 12:40:48 INFO] Steady state hypothesis is met! [2020-03-18 12:40:50 INFO] Finished verification conditions duration [2020-03-18 12:40:50 INFO] Starting verification cool-down period of None seconds [2020-03-18 12:40:52 INFO] Finished verification cool-down period [2020-03-18 12:40:53 INFO] Stopping verification measurements. 4 measurements taken [2020-03-18 12:40:53 INFO] Triggering any verification rollbacks [2020-03-18 12:40:53 INFO] Let' s rollback... [ 2020 -03-18 12 :40:54 INFO ] No declared rollbacks, let ' s move on. [ 2020 -03-18 12 :40:55 INFO ] Finished triggering any verification rollbacks [ 2020 -03-18 12 :40:57 INFO ] Finished running verification: Staging Console should respond within 500 milliseconds with a dummy condition applied. The only difference is when the chaos verify is provided with an HTTP resource, it downloads the verification first. The execution then performs the following steps: Validate the verification/experiment is syntactically correct and if it is valid it will run it. The steady state hypothesis is checked. Execute any methods in the verification. The steady state hypothesis is then checked again. Then a process is started that will execute the Steady State Hypothesis at the frequency-of-measurement defined in the Verification, for the duration-of-conditions (in the case above it takes a measurement every 3 seconds for a period of 10 seconds). Finally if there are any rollbacks then these are executed. When connected to ChaosIQ the result of running a Verification can be seen on the insights page: If you select the details button for your Verification can view the detail of the Verification execution: The details view includes information about the Objective, the Measurement used and the Verification. It shows the Verification Run Timeline that includes a timeline chart of samples.","title":"Run and Verify"},{"location":"run-and-verify/run-and-verify/#chaos-run","text":"the chaos run command will execute the experiment given as the SOURCE parameter, an experiment can be specified either a local file or a HTTP resource: ENDPOINT_URL = https://httpstat.us/200?sleep = 2000 ; \\ chaos run https://raw.githubusercontent.com/open-chaos/experiment-catalog/master/local/url-responds/url-responds.json will give output similar to: [ 2020 -03-18 10 :21:26 INFO ] Validating the experiment 's syntax [2020-03-18 10:21:26 INFO] Experiment looks valid [2020-03-18 10:21:26 INFO] Running experiment: Checks the hypothesis that a URL responds with a 200 status [2020-03-18 10:21:28 INFO] Execution available at http://console.chaosiq.dev/ChaosIQ/chaos-ebn/executions/6f38b6c5-cf44-4dec-a7b5-7ec6ee03352a [2020-03-18 10:21:29 INFO] Steady state hypothesis: Application is normal [2020-03-18 10:21:31 INFO] Probe: application-must-respond-normally [2020-03-18 10:21:35 INFO] Steady state hypothesis is met! [2020-03-18 10:21:38 INFO] Action: dummy step [2020-03-18 10:21:40 INFO] Steady state hypothesis: Application is normal [2020-03-18 10:21:43 INFO] Probe: application-must-respond-normally [2020-03-18 10:21:46 INFO] Steady state hypothesis is met! [2020-03-18 10:21:47 INFO] Let' s rollback... [ 2020 -03-18 10 :21:49 INFO ] No declared rollbacks, let ' s move on. [ 2020 -03-18 10 :21:50 INFO ] Experiment ended with status: completed If that same experiment is stored locally in a file e.g. url-responds.json , it can be executed as: ENDPOINT_URL = https://httpstat.us/200?sleep = 2000 ; \\ chaos run url-responds.json The output will be the same as shown above, the only difference is when the chaos run is provided with a URL it downloads the experiment from the HTTP resource first. The execution then performs the following steps: Validate the experiment and if it is syntactically valid it will run it. The steady state hypothesis is checked. Execute any methods in the experiment (the experiment can include an array of methods). The steady state hypothesis is then checked again. Finally if there are any rollbacks then these are executed. When connected to ChaosIQ the result of running an Experiment can be seen on the Executions pages: If you select the details button for your Experiment can view the detail of the execution: If you expand the Experiment Steady-State Hypothesis you can see the Steady-State used:","title":"Chaos Run"},{"location":"run-and-verify/run-and-verify/#chaos-verify","text":"The chaos verify command is added to the Chaos Toolkit CLI by the ChaosIQ plugin. A chaos verify command will execute the verification provided the SOURCE parameter. A verification can be specified either a local file or a HTTP resource: chaos verify https://console.chaosiq.dev/assets/verifications/13e11c55-8fd9-4737-b43f-b62ea763cc6f.json If that same verification is downloaded and stored locally in a file e.g. verify-staging-dummy-action.json , it can be executed as: chaos verify verify-staging-dummy-action.json The output is similar for both commands: [ 2020 -03-18 12 :40:30 INFO ] Validating the experiment 's syntax [2020-03-18 12:40:30 INFO] Experiment looks valid [2020-03-18 12:40:30 INFO] Verification looks valid [2020-03-18 12:40:31 INFO] Execution available at http://console.chaosiq.dev/ChaosIQ/Staging/executions/68158971-8ed1-45fd-815c-a92233c402f9 [2020-03-18 12:40:33 INFO] Started run ' 8a99aadf-f9b9-4053-8a3f-ad4cb76ed55c ' of verification ' Staging Console should respond within 500 milliseconds with a dummy condition applied. ' [2020-03-18 12:40:34 INFO] Starting verification warm-up period of None seconds [2020-03-18 12:40:34 INFO] Finished verification warm-up [2020-03-18 12:40:34 INFO] Triggering verification conditions [2020-03-18 12:40:35 INFO] Starting verification measurement every 3 seconds [2020-03-18 12:40:35 INFO] Running verification measurement 1 [2020-03-18 12:40:35 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:35 INFO] Probe: http-response-time [2020-03-18 12:40:35 INFO] Steady state hypothesis is met! [2020-03-18 12:40:37 INFO] Action: dummy step [2020-03-18 12:40:39 INFO] Running verification measurement 2 [2020-03-18 12:40:39 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:39 INFO] Probe: http-response-time [2020-03-18 12:40:39 INFO] Steady state hypothesis is met! [2020-03-18 12:40:40 INFO] Finished triggering verification conditions [2020-03-18 12:40:40 INFO] Starting verification conditions for 10 seconds [2020-03-18 12:40:43 INFO] Running verification measurement 3 [2020-03-18 12:40:43 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:43 INFO] Probe: http-response-time [2020-03-18 12:40:44 INFO] Steady state hypothesis is met! [2020-03-18 12:40:48 INFO] Running verification measurement 4 [2020-03-18 12:40:48 INFO] Steady state hypothesis: Staging Console should respond within 500 milliseconds [2020-03-18 12:40:48 INFO] Probe: http-response-time [2020-03-18 12:40:48 INFO] Steady state hypothesis is met! [2020-03-18 12:40:50 INFO] Finished verification conditions duration [2020-03-18 12:40:50 INFO] Starting verification cool-down period of None seconds [2020-03-18 12:40:52 INFO] Finished verification cool-down period [2020-03-18 12:40:53 INFO] Stopping verification measurements. 4 measurements taken [2020-03-18 12:40:53 INFO] Triggering any verification rollbacks [2020-03-18 12:40:53 INFO] Let' s rollback... [ 2020 -03-18 12 :40:54 INFO ] No declared rollbacks, let ' s move on. [ 2020 -03-18 12 :40:55 INFO ] Finished triggering any verification rollbacks [ 2020 -03-18 12 :40:57 INFO ] Finished running verification: Staging Console should respond within 500 milliseconds with a dummy condition applied. The only difference is when the chaos verify is provided with an HTTP resource, it downloads the verification first. The execution then performs the following steps: Validate the verification/experiment is syntactically correct and if it is valid it will run it. The steady state hypothesis is checked. Execute any methods in the verification. The steady state hypothesis is then checked again. Then a process is started that will execute the Steady State Hypothesis at the frequency-of-measurement defined in the Verification, for the duration-of-conditions (in the case above it takes a measurement every 3 seconds for a period of 10 seconds). Finally if there are any rollbacks then these are executed. When connected to ChaosIQ the result of running a Verification can be seen on the insights page: If you select the details button for your Verification can view the detail of the Verification execution: The details view includes information about the Objective, the Measurement used and the Verification. It shows the Verification Run Timeline that includes a timeline chart of samples.","title":"Chaos Verify"},{"location":"run-and-verify/verification-format/","text":"The Verification format is an experiment format that has the addition of an Extension . An example Verification extension is: \"extensions\" : [ { \"name\" : \"chaosiq\" , \"objective_id\" : \"48637aae-11a0-4f16-816f-55faef12d5d0\" , \"verification\" : { \"id\" : \"2adfd65c-ba38-4482-a73e-eb26252e4ebc\" , \"duration-of-conditions\" : 180 , \"frequency-of-measurement\" : 2 }, \"experiment_id\" : \"338e26f6-6ff6-42f8-a181-e7df9cbf385e\" } ] The extension identifies chaosiq as the vendor and then provides a number of custom properties: objective_id: this provides a mapping from the Verification to an Objective. verification: the Verification includes a number of further properties: id: a unique identifier for the Verification. duration-of-condition: this is the deration for the Verification in seconds, this is how long the Verification will run for frequency-of-measurement: this is the frequency that the measurement will be taken at, in this case the measure will be taken at every 2 seconds. The steady state hypothesis in the experiment is used as the measurement. Example Verification { \"title\" : \"Staging console can survive real pod death\" , \"description\" : \"N/A\" , \"configuration\" : {}, \"secrets\" : {}, \"extensions\" : [ { \"name\" : \"chaosiq\" , \"objective_id\" : \"48637aae-11a0-4f16-816f-55faef12d5d0\" , \"verification\" : { \"id\" : \"2adfd65c-ba38-4482-a73e-eb26252e4ebc\" , \"duration-of-conditions\" : 180 , \"frequency-of-measurement\" : 2 }, \"experiment_id\" : \"338e26f6-6ff6-42f8-a181-e7df9cbf385e\" } ], \"tags\" : [], \"steady-state-hypothesis\" : { \"title\" : \"Staging Console is Available\" , \"probes\" : [ { \"name\" : \"http-response-time\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscloud.probes.http\" , \"func\" : \"time_http_call\" , \"arguments\" : { \"url\" : \"https://console.chaosiq.dev\" } }, \"tolerance\" : { \"name\" : \"http-response-time-under\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscloud.tolerances.http\" , \"func\" : \"response_time_under\" , \"arguments\" : { \"duration\" : 500 } } } } ] }, \"method\" : [ { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"chaosiq-console\" , \"label_selector\" : \"chaosiq-saas-backend-6755597d54-8npfz\" , \"all\" : false , \"qty\" : 1 , \"rand\" : false } } } ] } In the full verification above: The verifications title and description are meant for humans and therefore should be as descriptive as possible to clarify the verifications rationale. Configuration and Secrets are optional and is same as for for an Experiment Configuration and Experiment Secrets . Steady State Hypothesis - this is used in this case as a measure of your system. Method - this is used to apply some condition to your system, in this case this is to kill a kubernetes pod.","title":"Verification Format"},{"location":"run-and-verify/verification-format/#example-verification","text":"{ \"title\" : \"Staging console can survive real pod death\" , \"description\" : \"N/A\" , \"configuration\" : {}, \"secrets\" : {}, \"extensions\" : [ { \"name\" : \"chaosiq\" , \"objective_id\" : \"48637aae-11a0-4f16-816f-55faef12d5d0\" , \"verification\" : { \"id\" : \"2adfd65c-ba38-4482-a73e-eb26252e4ebc\" , \"duration-of-conditions\" : 180 , \"frequency-of-measurement\" : 2 }, \"experiment_id\" : \"338e26f6-6ff6-42f8-a181-e7df9cbf385e\" } ], \"tags\" : [], \"steady-state-hypothesis\" : { \"title\" : \"Staging Console is Available\" , \"probes\" : [ { \"name\" : \"http-response-time\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscloud.probes.http\" , \"func\" : \"time_http_call\" , \"arguments\" : { \"url\" : \"https://console.chaosiq.dev\" } }, \"tolerance\" : { \"name\" : \"http-response-time-under\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscloud.tolerances.http\" , \"func\" : \"response_time_under\" , \"arguments\" : { \"duration\" : 500 } } } } ] }, \"method\" : [ { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"chaosiq-console\" , \"label_selector\" : \"chaosiq-saas-backend-6755597d54-8npfz\" , \"all\" : false , \"qty\" : 1 , \"rand\" : false } } } ] } In the full verification above: The verifications title and description are meant for humans and therefore should be as descriptive as possible to clarify the verifications rationale. Configuration and Secrets are optional and is same as for for an Experiment Configuration and Experiment Secrets . Steady State Hypothesis - this is used in this case as a measure of your system. Method - this is used to apply some condition to your system, in this case this is to kill a kubernetes pod.","title":"Example Verification"}]}